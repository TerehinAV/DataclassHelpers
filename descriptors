"""
Dataclass field descriptors
"""
import traceback
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Callable, List, Union, Dict, Any


class FieldDescriptor:
    pass


class SingleObject:
    pass


COMMON_DATE_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

DATE_FORMATS = [
    COMMON_DATE_TIME_FORMAT,
    "%Y%m%dT%H%M%S",
    "%Y%m%dT%H%M",
    "%Y.%m.%d %H:%M",
    "%Y%m%dT%H%M%S"
]


class DateTimeDescriptor:
    """
    Datetime descriptor
        it supports:
            - datetime string values, datetime objects
            - several dt formats
    """
    def __init__(self, default: Optional[datetime] = None, default_factory: Optional[Callable] = None):
        if callable(default_factory):
            self.default_factory = default_factory
        elif isinstance(default, datetime):
            self.default_factory = lambda: default
        else:
            self.default_factory = self._default_time

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self._name, self.default_factory())

    def __set__(self, instance, value):
        if not value:
            value = self.default_factory()
        elif isinstance(value, str):
            value = self._parse_date_string(value, self.default_factory())
        elif not isinstance(value, datetime):
            value = self.default_factory()
        instance.__dict__[self._name] = value

    def __set_name__(self, owner, name):
        self._name = name

    @staticmethod
    def _parse_date_string(value, default):
        for date_format in DATE_FORMATS:
            try:
                return datetime.strptime(value, date_format)
            except ValueError:
                continue
        return default

    @staticmethod
    def _default_time():
        """Default time: now."""
        return datetime.now()


class FloatStringDescriptor:
    """
    Float descriptor
        it supports:
            - string values representing floats
            - int and float objects
            - default value or default factory
    """
    def __init__(self, default: Optional[float] = None, default_factory: Optional[Callable[[], float]] = None):
        if callable(default_factory):
            self.default_factory = default_factory
        elif isinstance(default, (int, float)):
            self.default_factory = lambda: float(default)
        else:
            self.default_factory = self._default_float

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self._name, self.default_factory())

    def __set__(self, instance, value: Union[str, int, float, None]):
        if value is None or value == '':
            value = self.default_factory()
        elif isinstance(value, str):
            try:
                value = float(value)
            except ValueError:
                value = self.default_factory()
        elif isinstance(value, (int, float)):
            value = float(value)
        else:
            value = self.default_factory()
        instance.__dict__[self._name] = value

    def __set_name__(self, owner, name):
        self._name = name

    @staticmethod
    def _default_float():
        """Default float value: 0.0."""
        return 0.0


class IntStringDescriptor:
    """
    Integer descriptor
        it supports:
            - string values representing integers
            - int and float objects
            - default value or default factory
    """
    def __init__(self, default: Optional[int] = None, default_factory: Optional[Callable[[], int]] = None):
        if callable(default_factory):
            self.default_factory = default_factory
        elif isinstance(default, (int, float)):
            self.default_factory = lambda: int(default)
        else:
            self.default_factory = self._default_int

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self._name, self.default_factory())

    def __set__(self, instance, value: Union[str, int, float, None]):
        if value is None or value == '':
            value = self.default_factory()
        elif isinstance(value, str):
            try:
                value = int(float(value))  # на случай строки вроде "12.0"
            except ValueError:
                value = self.default_factory()
        elif isinstance(value, (int, float)):
            value = int(value)
        else:
            value = self.default_factory()
        instance.__dict__[self._name] = value

    def __set_name__(self, owner, name):
        self._name = name

    @staticmethod
    def _default_int():
        """Default int value: 0."""
        return 0


@dataclass
class SingleObjectDescriptor(FieldDescriptor):
    """ Descriptor for sindle dataclass model """
    def __init__(self, object_class, default: Optional[SingleObject] = None, default_factory: Optional[Callable] = None):
        self.object_class = object_class
        if callable(default_factory):
            self.default_factory = default_factory
        elif isinstance(default, object_class):
            self.default_factory = lambda: default  # Преобразуем объект в фабрику
        else:
            self.default_factory = self._default_factory

    def __get__(self, instance, owner):
        if instance is None:
            return self
        # Возвращаем значение из __dict__ экземпляра, если оно существует
        return instance.__dict__.get(self._name, self.default_factory())

    def __set__(self, instance, value):
        if not value:
            value = self.default_factory()
        elif isinstance(value, dict):
            value = self.object_class(**value)
        elif not isinstance(value, self.object_class):
            value = self.default_factory()
        # Сохраняем значение в __dict__ экземпляра
        instance.__dict__[self._name] = value

    def __set_name__(self, owner, name):
        # Запоминаем имя атрибута, чтобы хранить значение в __dict__
        self._name = name

    def _default_factory(self):
        """ Empty search filter """
        try:
            return self.object_class()
        except TypeError:
            print()


@dataclass
class ObjectListDescriptor(FieldDescriptor):
    """ Descriptor for dataclass model list """
    def __init__(self, object_class, default: Optional[List[SingleObject]] = None, default_factory: Optional[Callable] = None):
        self.object_class = object_class
        if callable(default_factory):
            self.default_factory = default
        elif isinstance(default, list):
            self.default_factory = lambda: default
        else:
            self.default_factory = self._default_factory

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self._name, self.default_factory())

    def __set__(self, instance, value):
        if not value or not isinstance(value, list):
            value = self.default_factory()
        else:
            value = [self.object_class(**object_dto) for object_dto in value]
        instance.__dict__[self._name] = value

    def __set_name__(self, owner, name):
        self._name = name

    @staticmethod
    def _default_factory():
        """ Empty search filter """
        return []


@dataclass
class MapObjectDescriptor:
    """ Descriptor for map str:dataclass_model """
    def __init__(self, object_class, default: Optional[Dict[str, SingleObject]] = None, default_factory: Optional[Callable] = None):
        self.object_class = object_class
        if callable(default_factory):
            self.default_factory = default_factory
        elif isinstance(default, dict):
            self.default_factory = lambda: default
        else:
            self.default_factory = self._default_factory

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self._name, self.default_factory())

    def __set__(self, instance, value: Optional[Dict[str, Any]]):
        if not isinstance(value, dict):
            value = self.default_factory()
        else:
            result = {}
            for key, obj_data in value.items():
                if isinstance(obj_data, self.object_class):
                    result[key] = obj_data
                elif isinstance(obj_data, dict):
                    try:
                        result[key] = self.object_class(**obj_data)
                    except Exception as err:
                        # Fallback to raw dict if instantiation fails
                        print(f"{traceback.format_exc()}")
                        result[key] = obj_data
                else:
                    result[key] = obj_data
            value = result
        instance.__dict__[self._name] = value

    def __set_name__(self, owner, name):
        self._name = name

    @staticmethod
    def _default_factory():
        return {}
